# Getting started {#gettingstarted}

**Chapter lead author: Pepa ArÃ¡n**

## Learning objectives

After you've gone over the lecture and solved the exercises, you should be able to:

-   Work with R and RStudio on your computer
-   Know some R objects and basic classes
-   Follow basic good coding practices
-   Organize your workspace using R projects
-   Save your code and progress in an organized way

## Tutorial

### Working with R and RStudio

R is a free, open-source programming language and software environment for statistical computing and graphics. It is widely used, not only among statisticians and data miners for developing statistical software, but also by scientist in various domains for data analysis, visualisation, and modelling. RStudio is an integrated development environment (IDE) that provides a user-friendly "center stage" for your work in R (and Python, see [here](https://posit.co/blog/three-ways-to-program-in-python-with-rstudio/)).

#### Installing R and RStudio

To use R and RStudio, you will first need to download and install them on your computer.

-   To install R, go to the [CRAN website](https://cran.r-project.org/) and download the latest version of R for your operating system. Once the download is complete, follow the on-screen installation instructions for your operating system to install R.

-   To install RStudio, go to the [RStudio website](https://posit.co/download/rstudio-desktop/) and download the latest version of RStudio for your operating system. Once the download is complete, follow the installation instructions for your operating system to install RStudio.

#### The RStudio interface

RStudio provides a user-friendly interface for writing, running, and debugging R code. When you open RStudio, you will see the following:

![RStudio interface.](figures/RStudio_interface_screenshot.png)

The interface is divided into four main panels:

-   The **source editor** is where you can write, edit, and save your R code.
-   The **console** is where you can enter R commands and see the output.
-   The **environment** panel shows you the objects (variables, data frames, etc.) that are currently in your R session, as well as their values.
-   The **files, plots, help, etc.** panel shows you the files, plots, and other items that are currently in your R workspace, as well as help and documentation for R functions and packages. We will cover this in more detail later in this course.

#### Running R code

Once you have both programs installed, you can open RStudio and begin a new *R session*. To run R code using R Studio, follow these steps:

-   In the *source editor* panel, type your R code.
-   To run the code, you can either press the **Run** button or use the keyboard shortcut Ctrl + Enter (Windows) or Command + Enter (Mac).
-   The code will be executed in the *console* panel, and any output will be displayed there.
-   Alternatively, you can directly type single-statement R commands in the console and run them by pressing Enter.

For example, let's say you want to calculate the sum of the numbers 1, 2, and 3. You can write the following code in the console or in the source editor:

```{r}
# Calculate the sum of 1, 2, and 3
1 + 2 + 3
```

If you've entered it in the console, press Enter. If you've entered it in the source editor, you can press the **Run** button or use the keyboard shortcut to run the code. The output will be displayed in the console:

        > 1 + 2 + 3
        [1] 6

#### Base R operations

The R {base} package contains the basic functions which let R function as a programming language: arithmetic, input/output, basic programming support, etc. Its contents are always available when you start an R session. Here we introduce the main binary operators, which work on vectors, matrices and scalars.

Arithmetic operators:

-   `+` addition
-   `-` subtraction
-   `*` multiplication
-   `/` division
-   `^` or `**` exponentiation

Logical operators:

-   `>` greater than
-   `>=` greater than or equal to
-   `==` exactly equal to
-   `<` less than
-   `<=` less than or equal to
-   `!=` not equal

### R objects

In addition to running single statements in the R console, the output of a statement can be saved as a new *object*. There are many kinds of R objects, some of which are covered here and in future chapters.

#### Types of data

First, we will introduce the different types of data that one can encounter. We can classify variables according to what values they take.

-   *Numerical*: These variables can be measured quantitatively and their value is a number.
    -   *Continuous*: We say that a variable is continuous when it can take an infinite number of real values within an interval. One could consider unbounded variables (height above sea level) or restricted variables, like positive variables (weight of a person) or an interval (a proportion between 0 and 1).
    -   *Discrete*: When the variable can only take a finite number of values in an interval, we say it is discrete. A common example is count data, like the population of a city.
-   *Categorical*: The values are characteristics that cannot be quantified.
    -   *Binary*: These variables have two possible values: `TRUE` or `FALSE` (a variable indicating whether the person has siblings or not).
    -   *Nominal*: They describe a name, label, or category without a natural order (for example, the name of a person).
    -   *Ordinal*: Like their name indicates, ordinal variables are categorical and follow a natural order. For example, "terrible", "bad", "neutral", "good", "great". A numerical variable can sometimes be discretized and put into categories, like dividing a person's age into age groups (bins) "toddler", "child", "teenager", "adult".

Next, we will see how these different types of variables can be treated in R.

#### Variables and classes

In R, a *variable* is a named location in memory that stores a value. To create a variable, you simply assign a value to a name using the `<-` operator (or the `=` operator, which has an equivalent role when assigning values to a variable, but `<-` is preferred). For example:

```{r}
my_variable <- 5
```

This code creates a variable called `my_variable` and assigns the value `5` to it. You can access the value of a variable or any other object by simply referring to its name, like this:

```{r}
my_variable
```

When you run this code, the value of `my_variable` will be printed to the console. Running `print(my_variable)` is an alternative syntax, using the `print()` function.

In R, every object and value has a *class* that determines how it is stored and how it behaves. For example, the `5` in our example above is a number, so its class is `numeric`. To find out the class of a value or a variable, you can use the `class()` function, like this:

```{r}
class(5)
class(my_variable)
```

The most basic classes are:

-   `numeric` (`num`) - any real number, e.g. `2.375`
-   `integer` (`int`) - integer numbers, e.g. `2`
-   `character` (`chr`) - any string, e.g., `"fluxes"`
-   `logical` (`logi`) - binary, i.e., either `TRUE` or `FALSE`.
-   `factor` (`Factor`) - categorical data, the variable can only be one of a defined number of options, e.g., one of C3, C4, or CAM (the three pathways of photosynthesis). Factors may also be given an order.
-   `function` - a set of statements organized to perform a specific task, for example `mean()`

By default, any number is coerced as `"numeric"`. So if you want an integer value to have class `"integer"`, you need to specify it like this:

```{r}
my_variable <- as.integer(5)
class(my_variable)
```

Sometimes, you need to convert the class of an object, for example turning an `"integer"` number into a `"character"`. You can do so as follows:

```{r}
my_variable <- as.character(my_variable)
my_variable
class(my_variable)
```

Note that now, the values are in quotes `"5"`. This way, R interprets it as a text and you will not be able to do any numeric calculations with it anymore.

#### Vectors

A *vector* in R is a sequence of data elements of the same class. Vectors can be created with the `c()` function, which stands for *concatenate*, i.e., to link together in a series or chain. For example, the following code creates a numeric vector:

```{r}
x <- c(1, 2, 3, 4, 5)
```

To access the elements of a vector, you can use the square bracket notation. For example, the following code retrieves the second element of the vector `x`:

```{r}
x[2]
```

You can also use the square bracket notation to extract a sub-vector from a larger vector. For example, you can extract the second to fourth elements of the vector x:

```{r}
x[2:4]
```

Another useful property of vectors in R is that they can be easily combined using arithmetic operators. For example, adding the elements of two vectors `x` and `y` element-wise:

```{r}
x <- c(1, 2, 3)
y <- c(4, 5, 6)
x + y
```

R also supports vectors of other classes, for example character vectors. Since all elements must be of the same class, the most general class will be adopted. The following code concatenates the vectors `x` and `y`, followed by new character elements:

```{r}
z <- c(x, y, "seven", "eight")
z
class(z)
```

Operations on vectors are performed element-wise. For example, if we ask what numbers in `x` are greater than 2, we obtain a vector of logical values (and class `"logical"`):

```{r}
x > 2
```

#### Lists

*Lists* are R objects, of class `"list"`. They are a bit like vectors, but more flexible. They allow us to store different types of data, even if they are of different lengths or of different classes. They are created with the function `list()` and can be named or not. Here is an example where each element of the list is named.

```{r}
mylist <- list(
    temperatures = c(2.234, 1.987, 4.345), 
    my_favourite_function = mean, 
    my_favourite_course = "Applied Geodata Science"
    )
```

Similar to vectors, we can extract elements from lists, either by index `[[1]]` or by the name using `[["temperatures"]]` or `$temperatures`. Note the double `[[]]` here, indicating an element of a list as opposed to `[]` indicating an element of a vector. To get the entire vector of temperatures, do either of the three:

```{r}
mylist[[1]]
mylist[["temperatures"]]
mylist$temperatures
```

Note below how, if we index the list like we would index a vector, a list with just one element would be returned, rather than the element itself. `[` is used to subset a list (and a list is returned). In contrast, `[[` or `$` extract a single element from a list. A thorough explanation of these differences is given [here](https://r4ds.hadley.nz/base-r#sec-subset-many) and [here](https://r4ds.hadley.nz/base-r#sec-subset-one).

```{r}
mylist[1]  # returns a subset of the list as a new list
mylist[[1]]  # extracts the first element of the list (a vector)
```

To get the first temperature value, which is an element of the vector (at the same time an element of the list), we can run:

```{r}
mylist[["temperatures"]][1]
```

You can also append elements to the list (either way is possible):

```{r}
mylist[["my_second_favourite_function"]] <- median
mylist$my_second_favourite_function <- median
```

This was a very condensed introduction to vectors and lists. A more complete introduction is given [here](https://r4ds.had.co.nz/vectors.html).

#### Data frames

A *data frame*, an object of class `"data.frame"`, is essentially a table, consisting of named columns and rows. A data frame can be created as follows:

```{r}
df <- data.frame(name = c("Maria", "Peter", "Alex"),
                 age = c(13, 56, 30))
df
```

A data frame can also be understood as a list of vectors of equal length, whereby each vector vector makes up a column and each of these vectors (columns) contains values of the same type. This notion makes it also evident that the elements of a data frame can be accessed the same way like we access elements of lists. To get the vector corresponding to the column named `age`, we can do:

```{r}
df$age
```

Data frames can be also be treated as a *matrix*. Note that the first index refers to rows and the second to columns. For example:

```{r}
df[, 1]   # first column
df[2, ]   # second row
df[2,2]   # age of Peter
```

There are many more things you can do with data frames. Since they are central to analyzing data with R, we go into more detail in Chapter \@ref(programmingprimers) and have dedicated all of Chapter \@ref(datawrangling) to teach you how to work with data frames in a tidy way.

#### Functions

R *functions* can be applied to an object (or several objects) and return another object. For example, the `mean()` function can take a numeric vector as input and output the mean of its elements.

```{r}
mean(df$age)
```

Functions are also R objects and have class `"function"`. They are covered in more detail in Chapter \@ref(programmingprimers).

#### Missing values

R has two representations for missing values: `NA` and `NULL`. Similar objects also exist in other programming languages.

`NA` is an identifier to mark missing data and stands for *not available*. You will encounter this when reading data into a data frame, and some of its cells show `NA` because that value is missing. Also, if you ask for the fourth element of a vector of length 3, R returns `NA`.

```{r}
x[4]
```

In general, operations on vectors that contain at least one `NA` value return `NA`. For example:

```{r}
mean(c(1, 2, NA))
```

To remove all missing values in the function evaluation, the common argument to set in the respective function call is `na.rm`. By default, it is usually set to `FALSE`, but we can do:

```{r}
mean(c(1, 2, NA), na.rm = TRUE)
```

Furthermore, `NA` counts as an element in vectors. A variable assigned just `NA` would have length 1 (of class `"logical"`) and the vector above has length 3, as can be determined using the `length()` function, and has class `"numeric"`.

By contrast, `NULL` is the R null object or empty space. You can also assign `NULL` to a variable, which will then have length zero because it is empty. Functions may return `NULL` when no output was defined, or if an error occurred.

#### R environment

The set of objects (variables, data frames, etc.) defined during an R session are referred to as the *environment*. You can view the objects in RStudio in the **environment** panel in R Studio, grouped as Data, Values and Functions.

After closing an existing R session (e.g., after quitting RStudio), the environment defined by the used during that session will not be saved automatically and will be lost. To save your environment, go to the **Session** menu and select **Save Workspace As...**. This will save all your objects in a `.RData` file in your working directory. 

The *working directory* is the default location to which R writes to and reads files from. You can check what your current working directory is running `getwd()` in the command line.

However, this workflow is not recommended. Next, we will go over some more sophisticated ways of writing code and saving your progress.

#### Read and save objects

The function `save()` allows to save multiple R objects of any form as a single `.RData` file. This is how the environment of your R session is saved. This is how we would save several R objects:

```{r eval=FALSE}
save(df, df_small, file = "data/data_frames.RData")
```

`.RData` files are read into your environment using the `load()` function. This function loads the objects with the name that they were saved with.

```{r eval=FALSE}
load("data/data_frames.RData")
```

Alternatively, the function `saveRDS()` allows you save single R objects that can then be read into with a specific (potentially new) variable name. This is more transparent than using `save()` and `load()` and gives the user more control.

```{r, eval=F}
saveRDS(df_small, file = "data/df_small.rds")
df_small_2 <- readRDS("data/df_small.rds")
```

`save()` and `saveRDS()` create *binary* files that are fast to write and read, but only intelligible to R. Such files are commonly identified by the suffix `.rds`. It is recommended to name the `.rds` files according to the single object they contain. When publishing and sharing data, avoid file formats that are not readable across different platforms and programming languages. We will learn more about open source binary file formats in Chapter \@ref(datavariety).

### R scripts

Usually, multiple statements are needed to get, e.g., from reading data into R to final numbers and figures that make up a further analysis. Together, these multiple statements constitute a *workflow*. It is essential that all workflows that underlie results of publications are *reproducible*, that is, that another person can replicate your results using your code and certain data.

To make a workflow reproducible, the sequence of statements that you needed to carry out your analysis and produce outputs can be saved as an R *script*. A script is a text file named with the suffix `.R` to indicate that it is executable by R. It contains a sequence of R commands, which you can be executed, line by line, starting from the top.

To create a new script in RStudio, go to the **File** menu and select **New File \> R Script**. This will open a new script file in the source editor. You can then type your R code in the script file and save it to your computer.

To run a script, you can either use the **Source** button in the source editor or use the keyboard shortcut Ctrl + Shift + Enter (Windows) or Command + Shift + Enter (Mac). This will run all of the commands in the script file, in the order they are written, in the console. Alternatively, you can type into the console:

    > source("my_r_script.R")

Note that, to be able to run the code above, the file `my_r_script.R` must be in your current working directory.

### Style your code

Nice code is clean, readable, consistent, and extensible (easily modified or adapted). Ugly code works, but is hard to work with. There is no right or wrong about coding style, but certain aspects make it easier to read and use code. Here are a few points to consider.

#### Spaces and breaks

Adding enough white spaces and line breaks in the right locations greatly helps the legibility of code. Cramming variables, operators, and brackets without spaces leaves an unintelligible sequence of characters and it will not be clear what parts go together. Therefore, consider the following points:

-   Use spaces around operators (`=`, `+`, `-`, `<-`, `>`, etc.).
-   Use `<-`, not `=`, for allocating a value to a variable.
-   Code inside curly brackets should be *indented* (recommended: two white spaces at the beginning of each line for each indentation level - don't use tabs).

For example:

```{r eval=F}
if (temp > 5.0){
  growth_temp <- growth_temp + temp  
}
```

#### Variable naming

It is preferable to use concise and descriptive variable names. Different variable naming styles are being used. In this course, we use lowercase letters, and underscores (`_`) to separate words within a name (`_`). Avoid (`.`) as they are reserved for certain types of objects in R. Also, avoid naming your objects with names of common functions and variables since your re-definition will mask already defined object names.

For example, `df_daily` is a data frame with data at a daily resolution. Or `clean_daily` is a function that cleans daily data. Note that a verb is used as a name for a function and an underscore (`_`) is used to separate words.

It is also recommendable to avoid variable names consisting of only one character. This makes it practically impossible to search for that variable.

```{r eval=F}
# Good
day_01

# Bad
DayOne
day.one
first_day_of_the_month
djm1

# Very bad
mean <- function(x) sum(x)/length(x) # mean() itself is already a function
T <- FALSE # T is an abbreviation of TRUE
c <- 10 # c() is used to create a vector (example <- c(1, 2, 3))
```

#### Script style

Load libraries at the very beginning of a script, followed, by reading data from files. Functions should be defined in separate `.R` files, unless they are only a few lines long. Then, place the sequence of statements. The name of the script should be short and concise and indicate what the script does. 

Use comments to describe in human-readable text what the code does. Comments are all that appears to the right of a `#` and are code parts that are not interpreted by R and not executed. Adding comments in the code greatly helps you and others to read your code, understand what it does, modify it, and resolve errors (bugs).

To visually separate parts of a script, use commented lines (e.g., `#----`). The RStudio text editor automatically recognizes `----` added to the right end of a commented line and interprets it as a block of content which can be navigated by using the document (**Outline** button in the top right corner of the editor panel). 

Avoid reading entire workspace environments (e.g., `load(old_environment.RData)`), deleting environments `rm(list=ls())`, loading hidden dependencies (e.g., `.Rprofile`), or changing the working directory (`setwd("~/other_dir/"`) as part of a script.

Note that information about the author of the script, its creation date, and modifications, etc. should not be added as commented text in the file. In Chapter \@ref(codemgmt), we will learn about the code versioning control system *git*, which keeps track of all this as meta information associated with files.

A good and comprehensive best practices guide is given by the [tidyverse style guide](https://style.tidyverse.org/).

### R Markdown

[R Markdown](https://rmarkdown.rstudio.com/) files are an enhanced version of scripts. They combine formatted text and executable code chunks. They can either be compiled (*knitted*) into an HTML or PDF output, where code chunks are executed upon compilation and visualization outputs are directly placed into the output, or they can be run like a script entirely or each code chunk separately. Rmarkdown is ideal for **reporting**, i.e., writing your final document presenting your analysis results. When opened in RStudio, RMarkdown files appear in the Editor like this:

```{r label="rmarkdown", echo=FALSE, out.width="75%", fig.cap="R Markdown document opened in the source panel.", fig.align='center'}
knitr::include_graphics("./figures/rmarkdown_editor.png") 
```

As shown in Fig. \@ref(fig:rmarkdown), an RMarkdown file consists of a header that specifies the document properties, such as how it should be rendered (as an html page, a docx file or a pdf).

```bash
---
title: "Simple global map"
author: Alex Humboldt
output: html_document
---
```

Below the header follow the contents as either text or code *chunks*. Text is formatted using the [Markdown syntax](https://commonmark.org/help/). For example, a top-level section title is specified by `#` and a title of a section one level lower by `##`

Code chunks that contain executable R code are opened by a line ` ```{r} `. 

The document can be rendered by calling `rmarkdown::render()` on the command line or hitting the **Knit** button in the RStudio IDE. Depending on your settings a html file, pdf or docx file will be generated in your current directory (and or displayed in the IDE viewer). The RMarkdown source file shown in Fig. \@ref(fig:rmarkdown) is rendered to:

```{r label="rmarkdownrender", echo=FALSE, fig.cap="Rendered HTML output.", out.width="75%", fig.align='center'}
knitr::include_graphics("./figures/rmarkdown_render.png")
```

Note that the code chunk produced a figure as an output which was placed directly in the rendered html. This demonstrates the usefulness of RMarkdown as *notebooks* to document entire workflows and make their outputs reproducible. 


### Workspace management

Using *R projects* in combination with *Git* is the essence of efficient workspace management in R. All files that belong together are organised within one directory. This can be regarded as the project directory and is typically congruent with what belongs to the respective Git repository. By keeping an organized workspace, another person (or your future self) can find relevant files, run your code and reproduce your analysis workflow easily.

#### Installing Git

*Git* is a version control system (covered in detail in Chapter \@ref(codemgmt)) which is integrated in RStudio. Code repositories can then be hosted in the cloud, for example in [GitHub](https://github.com/). To use it later in this course (and throughout your career), let's set up these tools:

-   First, follow the Git download and installation instructions for your OS outlined [here](https://git-scm.com/downloads).
-   Once Git is installed, set up RStudio for version control by going to **Tools \> Global Options \> Git/SVN** and tick "Enable version control interface...". You can check that the path to your Git installation is correct.
-   If you don't have one already, create a GitHub account on <https://github.com> and sign in.
-   Connect your GitHub account with Git locally, using SSH keys. You should sequentially follow the instructions to [check for existing SSH keys](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys), [generate a new SSH key](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent), [add a new SSH key to your GitHub account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account) and finally [test your SSH connection](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/testing-your-ssh-connection). Note that, at the top of these websites, there's an option to choose your OS because the steps vary depending on the type of computer your work with.

Now you should be able to use Git in the **Terminal** panel in RStudio, whenever your R Project is also a repository. As mentioned above, we will start working with these tools in a few weeks and they will be a crucial part of the course.

#### R projects

RStudio also allows you to work with R projects. An R project is a collection of files and folders that you use for a specific analysis or data project. An R project makes it easier to organize and manage your files and keep track of your work.

To create a new R project, go to the **File** menu and select **New Project...**. This will open the *New Project* dialog, where you can choose where to save your project and what type of project to create. The current project that you are working on is shown on the upper right corner of the RStudio interface. Here you can also switch between existing projects or create a new one.

![R Project menu.](figures/RStudio_RProject_screenshot.png)

When starting a new project, a file `<project_name.Rproj>` is created. It sits in the project directory and stores information about your last session (settings, open files, etc.) and optionally (not recommended) the environment of that session. The use of R projects also automatically enables useful features in RStudio for easy package, website, or book building and lets you manage Git for the repository corresponding to the project.

When you want to continue working on an existing R project, you can start a new session by clicking on your `<project_name.Rproj>` file. This restores settings from your last R session, including the variables in your environment, and sets your working directory to the project directory. Nevertheless, we recommend to start by emptying your environment and loading your data and variables using the code you previously wrote. That way, you ensure that your results are reproducible.

#### Folder structure

Once you have created an R project, you can create new scripts and other files within the project. These files will be organized in a folder structure, which you can view and manage in the **files, plots, help, etc.** panel.

For example, keep source files where R functions are defined in `./R` (where . refers to the current project directory), data files in `./data` and visualizations in `./fig`. It's advisable to write output files, created by the code of your project, to sub-directories within the project directory. To read and write from/to files you should use relative paths (relative to the project's root directory), like any of the two equivalent following options:

    > source("./R/my_r_script.R")
    > source("R/my_r_script.R")

A project directory should only contain code, data and outputs that belong to this one project. Stuff that may belong to multiple projects should be kept somewhere else. For example, keep original data (e.g., the raw data files that you created when collecting the data in the field, or data files you downloaded from the web) outside the project directory. Exceptions are small data files, which you can keep in `./data_raw`.

It is advisable to create a separate data directory outside the project (e.g., `~/data/`, where \~ refers to your home directory) that holds all the original data you ever downloaded, or obtained from peers, or gathered yourself. Within such a data directory, you can put files from different sources into separate sub-directories and add a description file (e.g., `~/data/some_data_source/README`) defining by whom, from where and when the data was obtained and defining data use policy.

You can find an [R project template](https://github.com/geco-bern/R_proj_template) in the GECO GitHub page. It shows an example of how you can organize your files into folders. Using such a template removes the overhead of designing a structure for each new project and can help you keep your work organized and make it easier to reuse and share your code.

## Exercises

Alright, let's get started with the first exercise! First, set up a new R project dedicated to this course:

-   Choose the location in your computer for your project and create a folder with an appropriate name. Then open RStudio and follow the instructions from the tutorial to create a new R Project.

-   The first file in your new R project will be an R Markdown (`.Rmd`) file which you can use to copy text and code from the different chapters of this book and try running the code yourself. Create such a file by clicking on the "new file" menu at the top left of RStudio and selecting **R Markdown ...**, give it a title and save.

Let's go over the basics of working with R Markdown (inspired by [this exercise](https://github.com/EcoForecast/EF_Activities/blob/master/Exercise_01_RPrimer.Rmd)).

-   To render a `.Rmd` file into an HTML file that reads like this book, you have to *knit* the document. To do this, you will need the {knitr} package. Install is by running `install.packages("knitr")` in the R console. Restart your R session and when it's ready, you should see a blue yarn icon above the source panel saying **Knit**. Knit your `.Rmd` document and check out the result. A new file with the same name but `.html` extension has been created and opened by RStudio for preview.
-   Feel free to delete the example text and code from your file to start with a clean slate. But don't delete the header delimited by `---`. You can modify the `.Rmd` file but not the `.html` file. To update the content of the nicely readable `.html` you will need to knit again. Knitting is also a very good way to check that all your code runs.
-   All your code should be placed into what we call "R chunks". When you run a chunk (on the green arrow) you will see the output of the code below it.
-   You can take notes or write answers in normal text outside those chunks. This [Markdown cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) can help you use its formatting capabilities, like titles, highlighting, mathematical formulas...

Now that you are set up, here are few exercises to get you started - remind yourself often of the guidelines on proper coding to make your life easier! Create a new `.R` file inside the project folder for solving the exercises.

-   Perform a little magic trick: Start with any number between 1 and 20 and do the calculations below. Create three variables: The original value, the value that is overwritten in every calculation, and a final value. Calculations: Add 1, double the number, add 4, divide by 2, subtract the original number.

-   Play around with different values, what do you find?

-   Advanced: Can you turn the little magic trick into a function that checks if the original value is an integer ([hint](https://statisticsglobe.com/check-if-number-is-integer-in-r)) between 1 and 20 and prints the final value at the end?

-   Clean up the code chunk below following the {tidyverse} style guide. Run the statements in your console - do they work? If not, why?

```{r eval=FALSE}
anothervariable = c(1)
seq <- vector(1,2 3 ,4)
is_true <- T
list(a=1, b = This is some really bad code}
var <- 7
my_new_function(this_is_a_very_long_argument = "value 1", and_this_is_another_very_long_argument = "value 2", short_but_still_long_argument = NA )
```
